import Complexity.Features.LexicalFeatures
import Complexity.TextDocument._
import Complexity.TextDocument
import edu.arizona.sista.processors.corenlp.CoreNLPProcessor
import Complexity.Utils.Testing._
import edu.arizona.sista.struct.Counter

import scala.collection.parallel.immutable.ParVector

/**
  * Created by mcapizzi on 3/25/16.
  */
class DocumentTests extends GeneralTest {

  //file to use for test
  val file = "0001AL_OwlAndMoon.txt"

  //create processor
  val p = new CoreNLPProcessor(withDiscourse = true)

  //make ProcessedParagraphs
  val procPars = makeProcPars(file)

  //annotate
  procPars.foreach(_.annotate)

  //make TextDocument
  val td = new TextDocument(procPars)

  //features
  val lex = new LexicalFeatures(td)

  ///////tests///////

  "Words without punctuation" should "be shorter than words with punctuation" in {
    for (paragraph <- procPars) {
      val withPunct = paragraph.words(withPunctuation = true).flatten
      val withoutPunct = paragraph.words(withPunctuation = false).flatten
      assert(withPunct.length > withoutPunct.length)
    }
  }

  "The proper nouns" should "be Owl and Moon" in {
    assert(td.properNounsCounter.size == 2)
  }

  "The tags counter" should "have the same value whether generated by .foldApply or by .foldApplyCounter" in {
    val tagCounterList = td.parParagraphs.map(_.buildCounters).map(_._1("tags"))
    val generalFold = foldApply(tagCounterList, new Counter[String], (a: Counter[String],b: Counter[String]) => a + b)
    val counterFold = foldApplyCounter(tagCounterList, new Counter[String], (a,b) => a + b)

    assert(generalFold == counterFold)

  }

  "Filtered stop word counter " should "not contain determiners or conjunctions" in {
    assert(
      !td.filterStopWords("words").keySet.map(_._2).contains("DT") &&
      !td.filterStopWords("lemmas").keySet.map(_._2).contains("DT") &&
      !td.filterStopWords("words").keySet.map(_._2).contains("CC"))
      !td.filterStopWords("lemmas").keySet.map(_._2).contains("CC"))
    )
  }




}

